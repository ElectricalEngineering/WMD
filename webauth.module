<?php
/**
 * @file
 * Authenticates users through Stanford WebAuth
 *
 */

define('WEBAUTH_DOMAIN', 'stanford.edu');
include_once(dirname(__FILE__) . '/WebAuthSession.inc');

/**
 * Implementation of hook_boot()
 *
 * This functions very very early, before most of Drupal has even loaded.
 *
 * The sole purposes of this function is to ensure HTTPS protocol, and
 * the security of the session.
 */
function webauth_boot() {

  if (!empty($_SERVER['HTTPS'])) {
    global $base_url, $user, $base_path;

    // Mandate HTTPS for sessions.
    ini_set('session.cookie_secure', 1);

    // Session cookies should be deleted when the browser session ends
    ini_set('session.cookie_lifetime', 0);

    $base_url = str_replace('http://', 'https://', $base_url);

    // Set a flag to indicate the user is logged in and that there are
    // secure cookies. Since sessions for logged in users are only sent
    // through HTTPS, those sessions won't be sent through HTTP.
    // This cookies lets WMD know to redirect the user to an HTTPS version
    // of the site so that those secure cookies can be received.
    if ($user->uid > 0) {
      setcookie("WMDsecureLogin", 1, time()+3600, $base_path);
    }
  }
  elseif (isset($_COOKIE["WMDsecureLogin"]) && $_COOKIE["WMDsecureLogin"]) {
    // A session seems to exist, but we are not in HTTPS.
    // Redirect so we can start secure session.
    global $base_url;
    $query = '';
    if (isset($_GET['q']) && !empty($_GET['q'])) {
      $query = '?q=' . $_GET['q'];
    }
    $url = $base_url . $query;
    $url = str_replace('http://', 'https://', $url);
    header("Location: $url");
  }
}


/**
 * Implementation of hook_init().
 *
 * If a user was created via webauth, we validate their session there.
 *
 * This function also ensures that webauth is handling 403s, and that
 * pages for logged in users are not cached in browsers.
 */

function webauth_init() {
  global $user;

  // Make sure we are handling 403 errors to implement auto-login
  $access_denied_page = variable_get('site_403', '');
  if ($access_denied_page != 'webauth/403') {
    variable_set('site_403', 'webauth/403');
  }

  // Pages for logged in users should not be cached
  if ($user->uid > 0) {
    header("Cache-Control: no-store, no-cache, must-revalidate");
  }

  // End the session and log user out if:
  // the user is logged in as a WebAuth user and:
  // either the user no longer has a webauth_at cookie
  // or the user's token has expired, or is not there
  $no_check_php_loop = (bool) (array_pop(explode('/', $_GET['q'])) != 'check.php');
  if ($user->uid > 0 && $no_check_php_loop) {
    // We only want to go further if this user is authenticated via WebAuth
    if (db_result(db_query("SELECT * FROM {authmap} WHERE uid = %d and module = 'webauth'", $user->uid))) {
      if ((!isset($_COOKIE['webauth_at'])) ||
	      (!isset($_SESSION['wa_session_data']['wa_token_expiration'])) ||
		  ($_SESSION['wa_session_data']['wa_token_expiration'] <= time())
		 ) {
        // Destroy the current session:
        session_destroy();
        // Only variables can be passed by reference workaround.
        $null = NULL;
        user_module_invoke('logout', $null, $user);
        // Load the anonymous user
        $user = drupal_anonymous_user();
      }
    }
  }
}

/**
 * Implementation of hook_menu().
 */

function webauth_menu() {
  $items = array();

  // Setup our authentication URL
  $path = variable_get('webauth_path', conf_path() . '/webauth') . '/login';

  $items[$path] = array(
    'page callback' => 'webauth_return',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['webauth/403'] = array(
    'page callback' => 'webauth_error_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['admin/settings/webauth'] = array(
    'title' => 'WebAuth',
    'description' => 'Authenticate through Stanford WebAuth',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webauth_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'webauth.admin.inc',
  );

  $items['admin/settings/webauth/settings'] = array(
    'title' => 'WebAuth Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/settings/webauth/authorizations'] = array(
    'title' => 'Authorizations',
    'description' => 'Edit the users and groups that are required for access.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webauth_admin_users'),
    'access arguments' => array('administer site configuration'),
    'file' => 'webauth.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/settings/webauth/mappings'] = array(
    'title' => 'Role Mappings',
    'description' => 'Edit the groups that can use WebAuth for content access.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webauth_admin_groups'),
    'access arguments' => array('administer site configuration'),
    'file' => 'webauth.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Handle 403 errors by redirecting users to webauth for login.
 *
 * If, however, they are already logged in and don't have access
 * (for instance, a normal user requesting /admin), then display
 * a normal error message.
 */
function webauth_error_page() {
  global $wa_session, $user;
  if (!$wa_session) {
    $wa_session = new WebAuthSession();
  }
  if (!$user->uid) {
    $redirect = NULL;
    if (trim(variable_get('webauth_destination', '')) != '') {
      $redirect = trim(variable_get('webauth_destination', ''));
    }
    elseif (isset($_SERVER['REQUEST_URI'])) {
      $redirect = str_replace(base_path(), '', $_SERVER['REQUEST_URI']);
      $redirect = str_replace("?q=", '', $redirect);
    }
    $wa_session->getWeblogin($redirect);
  }
  if ($user->uid) {
    drupal_set_header('HTTP/1.1 403 Forbidden');
    drupal_set_title(t('Access denied'));
    $webauth_restrict_message = trim(filter_xss_admin(variable_get('webauth_restrict_message', 'This content has been restricted by the author or by the site administrator.')));
    if (empty($webauth_restrict_message)) {
      drupal_access_denied();
    }
    else {
      print theme('page', $webauth_restrict_message);
    }
    exit;
  }
}

/**
 * Function to return from webauth login from.
 *
 * This handles logging a user in and then redirecting them to the page they
 * were previously on.
 */
function webauth_return() {
  global $wa_session, $user;
  if (!$wa_session) {
    $wa_session = new WebAuthSession();
  }

  // If the user has no webauth_at cookie, redirect immediately to log in through WebAuth
  // After they go through there, they'll go through the menu system and come back
  // to this function again
  if (!isset($_COOKIE['webauth_at'])) {
    $wa_session->getWeblogin();
  }

  if ($user->uid == 0) {
    if ($wa_session->isValidSession()) {
      $form_state = array();
      $form_state['values']['name'] = $wa_session->getSessionData('wa_remote_user');
      $form_state['values']['pass'] = 'dummy';
      $form_state['weblogin']['server'] = variable_get('webauth_domain', WEBAUTH_DOMAIN);
      drupal_execute('user_login', $form_state);
    }
    else {
      session_destroy();  
      return $wa_session->getWeblogin();
    }
  }

  if (!$wa_session->isValidSession()) {
    drupal_set_message('Unknown error occurred.');
  }
  $return = $wa_session->getReturnUrl(TRUE);
  $login = variable_get('webauth_path', conf_path() . '/webauth') . '/login';
  if (substr($return, 0, strlen($login)) == $login) {
    $return = '';
  }
  drupal_goto($return);
}

/**
 * Implementation of hook_theme().
 */
function webauth_theme($existing, $type, $theme, $path) {
  return array(
    'webauth_htaccess' => array(
      'arguments' => array('groups' => NULL, 'require_valid_user' => NULL, 'users' => NULL, 'privgroups' => NULL, 'rewrite_url' => NULL),
      'template' => 'webauth_htaccess',
    ),
  );
}

/**
 * Implementation of hook_form_alter().
 *
 * This insures that user login elements are webauth-enabled.
 *
 * TODO: it should not be necessary to start a WebAuthSession() every time this
 * hook is invoked. Could be done more tactically.
 */
function webauth_form_alter(&$form, &$form_state, $form_id) {
  global $user, $base_url, $wa_session;

  if (!$wa_session) {
    $wa_session = new WebAuthSession();
  }

  switch ($form_id) {
    case 'user_profile_form':
      $account = $form['_account']['#value'];
      if (!empty($account->roles)) {
        if (in_array(variable_get('webauth_default_role', ''), array_keys($account->roles))) {
          // Hide elements for SUNet Users.
          $form['account']['name']['#type'] = 'hidden';
          $form['account']['name']['#value'] = $form['_account']['#value']->name;
          $form['account']['pass']['#type'] = 'hidden';
        }
      }
      break;
    case 'user_login_block':
    case 'user_login':
      if (isset($form_state['weblogin']['server'])) {
        $form['#validate'] = array(
          'user_login_name_validate',
          'webauth_login_validate',
          'user_login_final_validate',
        );
      }
      // drupal_execute() for user_login comes here, and we can lose our login
      // redirect context, so if we are on the auth path here, we should stop
      // altering at this point.
      //
      // I don't love this fix, but it's necssary given how the $wa_session
      // object is constructued at the moment.
      $path = variable_get('webauth_path', conf_path() . '/webauth') . '/login';
      if ($_GET['q'] == $path) {
        return;
      }

      // Build a link to wa_login.
      $secure_base_url = str_replace('http:', 'https:', $base_url);
      $webauth_login = $wa_session->getLoginUrl($_GET['q']);
      $wa_url = l(variable_get('webauth_link_text', 'Log in with your SUNet ID'), $webauth_login);
      $form['webauth_link'] = array(
        '#prefix' => '<div id="webauth-link">',  // make it themable
        '#value' => $wa_url,
        '#suffix' => '</div>',
        '#weight' => -10
      );

      if ($form_id == 'user_login_block') {
        $allow_local = variable_get('webauth_allow_local', TRUE);
        if (!$allow_local) {
          unset($form['name']);
          unset($form['pass']);
          unset($form['submit']);
          unset($form['links']);
        }
      }
      break;
  }
}

function webauth_form_user_pass_alter(&$form, &$form_state) {
  $form['name']['#description'] = filter_xss(t('Note: For local Drupal accounts only. Do not use this form to request a new password for a SUNet account. Use <a href="https://stanfordyou.stanford.edu">StanfordYou</a>.'));
  $form['#validate'][] = 'webauth_user_pass_validate';
}

function webauth_user_pass_validate(&$form, &$form_state) {
  $name = trim($form_state['values']['name']);

  // Try to load by email.
  $account = user_load(array('mail' => $name, 'status' => 1));
  if (!$account) {
    // No success, try to load by name.
    $account = user_load(array('name' => $name, 'status' => 1));
  }
  if ($account) {
    // If this is a WebAuth account, we should not let them request a one time login link
    if (db_result(db_query("SELECT * FROM {authmap} WHERE uid = %d and module = 'webauth'", $account->uid))) {
      form_set_error('name', t('%name is an account handled by WebAuth and its password cannot be changed here.<br />If you need to update your password, please use <a href="https://stanfordyou.stanford.edu">StanfordYou</a>.', array('%name' => $name)));
    }
  }
} 


/**
 * Implementation of hook_user().
 */
function webauth_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'login':
      // If this is a WebAuth account, check for roles and re-grant new roles.
      if (db_result(db_query("SELECT * FROM {authmap} WHERE uid = %d and module = 'webauth'", $account->uid))) {
        webauth_grant_roles($edit, $account);
      }
      break;
    case 'insert':
      // We only want to run these if the user is self-creating via webauth.
      // Otherwise an admin user will transpose their own values onto any
      // account they manually create.
      global $user;
      if ($user->uid == 0) {
        webauth_update_fields($edit, $account);
      }
      break;
    case 'delete':
      db_query("DELETE FROM {webauth_roles_history} WHERE uid = %d", $account->uid);
      break;
    case 'logout':
      if (isset($_COOKIE['WMDsecureLogin'])) {
        unset($_COOKIE['WMDsecureLogin']);
        setcookie('WMDsecureLogin', '', time() - 3600);
      }
      unset($_SESSION['wa_session_data']);
      unset($_SESSION['wa_return_url']);
  }
}

/**
 * This is a helper function to store webauth-derived data for the user account.
 */
function webauth_update_fields(&$edit, &$account) {
  global $wa_session;
  global $user;
  if ($user->uid == 0) {
    if (!$wa_session) {
      $wa_session = new WebAuthSession();
    }

    $mail = $wa_session->getSessionData('wa_ldap_mail');
    $mail =  isset($mail) ? $mail : $account->name;
    db_query("UPDATE {users} SET mail = '%s' WHERE uid = %d", $mail, $account->uid);
  }
}

/**
 * This is a helper function to grant drupal roles based on webauth data.
 *
 * This is called when new users are created via webauth, or when "local"
 * drupal users log in. It could also be invoked by other operations to
 * sync up a users roles based on their webauth settings.
 */
function webauth_grant_roles(&$edit, &$account) {
  global $wa_session;
  if (!$wa_session) {
    $wa_session = new WebAuthSession();
  }

  if ($wa_session->isValidSession()) {
    $groups = $wa_session->getLdapGroups();
    $new = array('roles' => $account->roles);

    // Add SUNet User role for all valid users.
    $default_name = db_result(db_query("SELECT name FROM {role} WHERE rid = %d", variable_get('webauth_default_role', 0)));
    if (variable_get('webauth_default_role', 0) != 0 && !isset($new['roles'][variable_get('webauth_default_role', 0)])) {
      $new['roles'][variable_get('webauth_default_role', 0)] = $default_name;
    }

    // Unserialize data.
    $data = unserialize($account->data);
    $data = is_array($data) ? $data : array();
    $current = array();

    // Find all roles that are in the webauth_roles table and add any ones that user is in.
    $result = db_query("SELECT r.rid, r.name, wr.wa_group AS `group`, wr.warid FROM {webauth_roles} wr INNER JOIN {role} r ON r.rid = wr.rid");
    while ($role = db_fetch_object($result)) {
      if (in_array($role->group, $groups)) {
        $new['roles'][$role->rid] = $role->name;
        $data['webauth_assigned_roles'][$role->rid] = $role->name;
        $current[$role->rid] = $role->rid;
        db_query("DELETE FROM {webauth_roles_history} WHERE warid = %d AND uid = %d", $role->warid, $account->uid);
        db_query("INSERT INTO {webauth_roles_history} (warid, uid, rid) VALUES (%d, %d, %d)", $role->warid, $account->uid, $role->rid);
      }
    }
    // Close out any groups they shouldn't have access to.
    $result = db_query("SELECT * FROM {webauth_roles_history} WHERE uid = %d", $account->uid);
    while ($role = db_fetch_object($result)) {
      if (!isset($current[$role->rid])) {
        unset($data['webauth_assigned_roles'][$role->rid]);
        unset($new['roles'][$role->rid]);
        db_query("DELETE FROM {webauth_roles_history} WHERE uid = %d AND rid = %d", $account->uid, $role->rid);
        db_query("DELETE FROM {users_roles} WHERE uid = %d AND rid = %d", $account->uid, $role->rid);
      }
    }

    $account->data = serialize($data);
    user_save($account, $new);
  }
}

/**
 * Perform webauth validation on users who come in via the normal Drupal login
 * form or block.
 */
function webauth_login_validate($form, &$form_state) {
  global $wa_session;
  if (!$wa_session) {
    $wa_session = new WebAuthSession();
  }
  if ($wa_session->isValidSession()) {
    user_external_login_register($form_state['values']['name'] . '@' . $form_state['weblogin']['server'], 'webauth');
    user_authenticate_finalize($form_state['values']);
  }
}

/**
 * Function to write out our .htaccess file.
 */
function webauth_write_htaccess() {

  $groups = array();
  $user_list = '';
  $rewrite_url = '';

  // Get all the available groups
  $result = db_query("SELECT DISTINCT(wa_group) AS `group` FROM {webauth_roles} WHERE rid > 2");
  while ($group = db_result($result)) {
    $groups[] = $group;
  }

  $user_list = array();
  $users = explode("\n", variable_get('webauth_require_users', ''));
  foreach ($users as $u) {
    $u = trim($u);
    if ($u != '') {
      $user_list[] = $u;
    }
  }

  $privgroup_list = array();
  $privgroups = explode("\n", variable_get('webauth_require_privgroups', ''));
  foreach ($privgroups as $p) {
    $p = trim($p);
    if ($p != '') {
      $privgroup_list[] = $p;
    }
  }

  // if clean URLs are disabled, we need to redirect users back to Drupal
  // after they have logged in
  if (!variable_get('clean_url', 0)) {
    $new_path = base_path() . '?q=' . variable_get('webauth_path', conf_path() . '/webauth') . '/login';
    $rewrite_url .= 'RewriteRule login(.*)$ ' . $new_path . '$1 [L,R=301]';
  }

  // Theme contents of the .htaccess file.
  $htaccess_file = theme('webauth_htaccess', $groups, variable_get('webauth_require_valid_user', 0), $user_list, $privgroup_list, $rewrite_url);

  // Get the path or create it inside the files dir.
  $webauth_path = variable_get('webauth_path', conf_path() . '/webauth');

  // Set .htaccess file location
  $webauth_htaccess = $webauth_path . '/.htaccess';

  // If webauth dir doesn't exist yet, create it.
  if (@is_dir($webauth_path) === FALSE) {
    // Create dir.
    mkdir($webauth_path, 0755);
  }

  // Copy necessary check.php file over.
  $default_check_file = drupal_get_path('module', 'webauth') . '/default/check.php';
  copy($default_check_file, $webauth_path . '/check.php');


  // Save .htaccess file to location.
  $fp = fopen($webauth_htaccess, 'w');
  fwrite($fp, $htaccess_file);
  fclose($fp);
}
